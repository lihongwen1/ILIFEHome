package com.ilife.home.robot.view;

import android.content.Context;
import android.graphics.Bitmap;
import android.graphics.Canvas;
import android.graphics.Color;
import android.graphics.DashPathEffect;
import android.graphics.Matrix;
import android.graphics.Paint;
import android.graphics.Path;
import android.graphics.PathEffect;
import android.graphics.PointF;
import android.graphics.PorterDuff;
import android.graphics.RectF;
import android.os.Looper;
import android.util.AttributeSet;
import android.view.MotionEvent;
import android.view.View;

import com.ilife.home.robot.R;
import com.ilife.home.robot.app.MyApplication;
import com.ilife.home.robot.bean.Coordinate;
import com.ilife.home.robot.bean.PartitionBean;
import com.ilife.home.robot.model.bean.SlamLineBean;
import com.ilife.home.robot.model.bean.VirtualWallBean;
import com.ilife.home.robot.utils.BitmapUtils;
import com.ilife.home.robot.utils.DataUtils;
import com.ilife.home.robot.utils.MyLogger;
import com.ilife.home.robot.utils.UiUtil;
import com.ilife.home.robot.utils.Utils;
import com.ilife.home.robot.view.helper.CleanAreaHelper;
import com.ilife.home.robot.view.helper.ForbiddenAreaHelper;
import com.ilife.home.robot.view.helper.RoomHelper;
import com.ilife.home.robot.view.helper.SegmentationRoomHelper;
import com.ilife.home.robot.view.helper.VirtualWallHelper;

import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.List;

/**
 * 900系列采用直接绘图方式
 * 生产者-消费者模式绘制bitmap,刷新UI，已绘制的点集放弃，只绘制新增的点集合（同步集合）。数据清空时，同步清空bitmap OPen-GL实现绘制图片
 */
public class MapView extends View {
    private int width, height;
    private static String TAG = "MapView";
    private Path roadPath, slamPath, obstaclePath, boxPath, roomGatePath;
    private float beforeDistance;
    public static final int MODE_NONE = 1;
    public static final int MODE_DRAG = 2;
    public static final int MODE_ZOOM = 3;
    public static final int MODE_ADD_VIRTUAL = 4;
    public static final int MODE_DELETE_VIRTUAL = 5;
    private float originalScale = 1, userScale = 1, systemScale = 1;//user-scale is the scale value generated by  scaling the screen by user
    private float baseScare = 1;//基准坐标缩放比例，以slam边缘占据view3/4，与view同坐标中心为标准

    private PointF sCenter, downPoint;//sCenter map缩放中心
    private Matrix matrix;
    private float dragX, dragY;
    private int[] colors;
    private static final int MIN_WALL_LENGTH = 20;
    private Bitmap deleteBitmap, rotateBitmap, pullBitmap, standBitmap;//删除电子墙的bitmap
    private List<SlamLineBean> lastLineBeans = new ArrayList<>();
    private ArrayList<Coordinate> pointList = new ArrayList<>();
    private boolean isSetExtraDrag;
    private float startX = 0, startY = 0, endX = 0, endY = 0;
    private Canvas slamCanvas;
    private Bitmap slamBitmap;
    private RectF slamRect = new RectF();
    private boolean robotSeriesX9;
    private boolean unconditionalRecreate;
    private int extraWH = 60;//额外的宽高
    private Runnable restoreRunnable;//控制延迟15s后恢复地图
    private boolean isNeedRestore = true;
    private int paddingBottom;//改变地图居中中心点
    private boolean needEndPoint = true;

    private VirtualWallHelper mVirtualWallHelper;
    private ForbiddenAreaHelper mForbiddenHelper;//全局禁区
    private CleanAreaHelper mCleanHelper;
    private SegmentationRoomHelper mSegmentHelper;//分割房间
    private RoomHelper mRoomHelper;
    private OT mOT = OT.NOON;//默认操作地图
    private int MAP_MODE;//标记操作地图的类型
    private final int ZOOM = 2;
    private final int DRAG = 3;
    private PaintManager mPaintManager;
    private PointF standPointF;//充电座
    private boolean isChargingPortDisplay = false;//是否展示充电座

    /**
     * map operation type
     */
    public enum OT {
        NOON(0),
        MAP(1),//操作地图：缩放，移动
        VIRTUAL_WALL(2),//虚拟墙
        GLOBAL_FORBIDDEN_AREA(3),//全局禁区
        MOP_FORBIDDEN_AREA(4),//抹地禁区
        SELECT_ROOM(5),//选房清扫
        PARTITION(6),//分区
        CLEAN_AREA(7),//划区清扫
        SEGMENT_ROOM(8);//分割房间
        final int nativeType;

        OT(int type) {
            this.nativeType = type;
        }
    }

    public OT getmOT() {
        return mOT;
    }

    public void setmOT(OT mOT) {
        this.mOT = mOT;
        if (mOT == OT.GLOBAL_FORBIDDEN_AREA || mOT == OT.MOP_FORBIDDEN_AREA) {
            mForbiddenHelper.setmFbdAreaType(mOT == OT.GLOBAL_FORBIDDEN_AREA ? ForbiddenAreaHelper.TYPE_GLOBAL :
                    ForbiddenAreaHelper.TYPE_MOP);
        }
    }

    public MapView(Context context) {
        super(context);
        init();
    }

    public MapView(Context context, AttributeSet attrs) {
        super(context, attrs);
        init();
    }

    public MapView(Context context, AttributeSet attrs, int defStyleAttr) {
        super(context, attrs, defStyleAttr);
        init();
    }

    public boolean isNeedEndPoint() {
        return needEndPoint;
    }

    public void setNeedEndPoint(boolean needEndPoint) {
        this.needEndPoint = needEndPoint;
    }

    public void setNeedRestore(boolean needRestore) {
        isNeedRestore = needRestore;
    }

    public void setRobotSeriesX9(boolean isX9) {
        this.robotSeriesX9 = isX9;
        if (isX9) {
            extraWH = 100;
        } else {
            extraWH = 60;
        }
    }

    private void init() {
        mPaintManager = new PaintManager();
        mVirtualWallHelper = new VirtualWallHelper(this);
        mForbiddenHelper = new ForbiddenAreaHelper(this);
        mSegmentHelper = new SegmentationRoomHelper(this);
        mCleanHelper = new CleanAreaHelper(this);
        mRoomHelper = new RoomHelper(this);
        colors = new int[]{getResources().getColor(R.color.obstacle_color), getResources().getColor(R.color.slam_color),
                getResources().getColor(R.color.color_00ffffff)};
        MAP_MODE = MODE_NONE;
        matrix = new Matrix();
        sCenter = new PointF(0, 0);
        downPoint = new PointF(0, 0);
        roadPath = new Path();
        roomGatePath = new Path();
        slamPath = new Path();
        obstaclePath = new Path();
        int deleteIconW = getResources().getDimensionPixelSize(R.dimen.dp_48);
        deleteBitmap = BitmapUtils.decodeBitmapFromResource(getResources(), R.drawable.operation_btn_closed, deleteIconW, deleteIconW);
        rotateBitmap = BitmapUtils.decodeBitmapFromResource(getResources(), R.drawable.operation_btn_angle, deleteIconW, deleteIconW);
        pullBitmap = BitmapUtils.decodeBitmapFromResource(getResources(), R.drawable.operation_btn_zoom, deleteIconW, deleteIconW);
        standBitmap = BitmapUtils.decodeBitmapFromResource(getResources(), R.drawable.operation_icon_stand, deleteIconW, deleteIconW);
        boxPath = new Path();
    }

    /**
     * 无条件刷新创建bitmap
     *
     * @param unconditionalRecreate
     */
    public void setUnconditionalRecreate(boolean unconditionalRecreate) {
        this.unconditionalRecreate = unconditionalRecreate;
        userScale = 1;
        originalScale = userScale;
    }

    public void setLeftTopCoordinate(int x, int y) {
    }

    /**
     * 设置地图模式
     *
     * @param MAP_MODE MODE_VIRTUAL 电子墙编辑模式
     */
    public void setMAP_MODE(int MAP_MODE) {
        this.MAP_MODE = MAP_MODE;
        if (MAP_MODE == MODE_ADD_VIRTUAL || MAP_MODE == MODE_DELETE_VIRTUAL) {
//            mVirtualWallHelper.setVirtualWall();
        }
    }

    public boolean isInMode(int mode) {
        return mode == MAP_MODE;
    }


    /**
     * 绘制路线地图，包含历史地图/即时地图
     * y坐标没有按照实际坐标绘制，1500-y
     *
     * @param roadList        事实地图数据
     * @param historyRoadList 历史地图数据
     */
    private void drawRoadMap(List<Integer> roadList, List<Integer> historyRoadList) {
        roadPath.reset();
        MyLogger.d(TAG, "drawRoadMap-----");
        List<Integer> allPoint = new ArrayList<>();
        if (historyRoadList != null) {
            allPoint.addAll(historyRoadList);
        }
        if (roadList != null) {
            allPoint.addAll(roadList);
        }
//        绘制历史路径坐标点，下一条路径的起始坐标为上一条路径的终点坐标
        boolean flag = false;
        if (allPoint.size() > 0) {
            for (int k = 0; k < allPoint.size() - 1; k += 2) {
                if (k == allPoint.size() - 2) {
                    endX = matrixCoordinateX(allPoint.get(k));
                    endY = matrixCoordinateY(1500 - allPoint.get(k + 1));
                }
                if (k == 0) {
                    startX = matrixCoordinateX(allPoint.get(0));
                    startY = matrixCoordinateY(1500 - allPoint.get(1));
                    roadPath.moveTo(startX, startY);//设置起点
                } else {
                    if (allPoint.get(k) == 400 && allPoint.get(k + 1) == 400) {
                        flag = true;
                        MyLogger.d(TAG, "new package data is arriving");
                        continue;
                    }
                    if (flag) {
                        flag = false;
                        roadPath.moveTo(matrixCoordinateX(allPoint.get(k)), matrixCoordinateY(1500 - allPoint.get(k + 1)));
                    } else {
                        roadPath.lineTo(matrixCoordinateX(allPoint.get(k)), matrixCoordinateY(1500 - allPoint.get(k + 1)));
                    }
                }
            }
        }
    }


    /**
     * X900系列绘图
     *
     * @param roadList
     * @param historyRoadList
     * @param slamBytes
     */
    public void drawMapX9(List<Integer> roadList, List<Integer> historyRoadList, byte[] slamBytes) {
        if (slamBitmap == null && slamCanvas == null) {
            return;
        }
        //drawing white road line
        drawRoadMap(roadList, historyRoadList);
        //drawing slam map
        if (slamBytes != null) {//900系列绘制路径时不绘制slam
            drawSlamMap(slamBytes);
        }
        slamCanvas.drawColor(Color.TRANSPARENT, PorterDuff.Mode.CLEAR);
        slamCanvas.save();
        slamCanvas.drawPath(slamPath, mPaintManager.changeColor(mPaintManager.getSlamPaint(), PaintColor.SLAM));
        slamCanvas.drawPath(obstaclePath, mPaintManager.changeColor(mPaintManager.getSlamPaint(), PaintColor.OBSTACLE));
        slamCanvas.drawPath(roadPath, mPaintManager.changeColor(mPaintManager.getLinePaint(), PaintColor.ROAD));
        //draw start point with green color
        if (startX != 0 || startY != 0) {
            slamCanvas.drawCircle(startX, startY, Utils.dip2px(MyApplication.getInstance(), 4), mPaintManager.changeColor(mPaintManager.getFillPaint(), PaintColor.OBSTACLE));
        }
        //draw end point with yellow color
        if (endX != 0 || endY != 0) {
            slamCanvas.drawCircle(endX, endY, Utils.dip2px(MyApplication.getInstance(), 6), mPaintManager.changeColor(mPaintManager.getFillPaint(), PaintColor.END_CIRCLE));
        }
        invalidateUI();
    }

    public PointF getStandPointF() {
        return standPointF;
    }

    public void drawMapX8(List<Coordinate> dataList) {
        MyLogger.d(TAG, "----------drawMapX8---------数据长度：   " + dataList.size());
        drawBoxMapX8(dataList);
        slamCanvas.drawColor(Color.TRANSPARENT, PorterDuff.Mode.CLEAR);
        /**
         * 绘制已清扫区域
         */
        slamCanvas.drawPath(boxPath, mPaintManager.changeColor(mPaintManager.getMapPaint(), PaintColor.SLAM));
        /**
         * 绘制障碍物
         */
        slamCanvas.drawPath(obstaclePath, mPaintManager.changeColor(mPaintManager.getMapPaint(), PaintColor.OBSTACLE));
        /**
         * 绘制room区域
         */
        slamCanvas.drawPath(roomGatePath, mPaintManager.changeColor(mPaintManager.getMapPaint(), PaintColor.ROOM_GATE));
        /**
         * 绘制路径
         */
        slamCanvas.drawPath(roadPath, mPaintManager.getRoadPaint());
        if (needEndPoint && endX != 0 && endY != 0) {
            slamCanvas.drawCircle(endX, endY, Utils.dip2px(MyApplication.getInstance(), 12 * baseScare / 30f), mPaintManager.changeColor(mPaintManager.getMapPaint(), PaintColor.END_CIRCLE));
        }
        invalidateUI();
    }


    /**
     * 清除所有绘图痕迹
     */
    public void clean() {
        mVirtualWallHelper.getVwPath().reset();
        roadPath.reset();
        slamPath.reset();
        boxPath.reset();
        obstaclePath.reset();
        roomGatePath.reset();
        if (slamCanvas != null) {
            slamCanvas.drawColor(Color.TRANSPARENT, PorterDuff.Mode.CLEAR);
        }
        invalidateUI();
    }

    public void resetCenter(int paddingBottom) {
        if (!isSetExtraDrag) {
            isSetExtraDrag = true;
            this.paddingBottom = paddingBottom;
            sCenter.set(width / 2f, (height - paddingBottom) / 2f);
        }
    }

    public void drawForbiddenArea(String data) {
        if (mForbiddenHelper != null) {
            mForbiddenHelper.setForbiddenArea(data);
            invalidateUI();
        }
    }

    /**
     * @param xMin
     * @param xMax
     * @param yMin
     * @param yMax
     */
    // TODO it should't be created ,when it's size is less than the old
    //the value of baseScare can affects the  sharpness of the map
    public void updateSlam(int xMin, int xMax, int yMin, int yMax) {
        MyLogger.e(TAG, "mapmap边界坐标" + "xM:" + xMin + "  xMax:  " + xMax + " yMin: " + yMin + "  yMax:   " + yMax);
        int xLength = xMax - xMin;
        int yLength = yMax - yMin;
        if (xLength <= 0 || yLength <= 0) {
            return;
        }
        /**
         * 计算坐标放大和缩放比例
         */
        baseScare = 20.0f;
        if (xLength * baseScare > width * 0.75 || yLength * baseScare > sCenter.y * 2 * 0.75) {
            MyLogger.d(TAG, "SYSTEM SCALE MAP -------------");
            float systemW = (width * 0.75f) / ((xLength * baseScare));
            float systemH = (sCenter.y * 2 * 0.75f) / ((yLength * baseScare));
            systemScale = Math.min(systemH, systemW);
            systemScale = new BigDecimal(systemScale).setScale(2, BigDecimal.ROUND_HALF_DOWN).floatValue();
            if (systemScale < 0.3f) {
                baseScare = new BigDecimal(baseScare * systemScale / 0.3f).setScale(0, BigDecimal.ROUND_HALF_DOWN).floatValue();
                systemScale = 0.3f;
            }
        }


        MyLogger.d(TAG, "xLength----" + xLength + "----yLength-----" + yLength + "---------height" + height + "---------width--------" + width);
        MyLogger.d(TAG, "--systemScale--:" + systemScale + "------baseScare----:" + baseScare + "------userScale-------" + userScale);
        slamRect.set(xMin, yMin, xMax, yMax);
        int needWidth = (int) ((xMax - xMin) * baseScare) + extraWH;
        int needHeight = (int) ((yMax - yMin) * baseScare) + extraWH;
        if (slamCanvas == null && slamBitmap == null) {
            slamBitmap = Bitmap.createBitmap(needWidth, needHeight, Bitmap.Config.ARGB_8888);
            slamCanvas = new Canvas(slamBitmap);
        } else if (slamBitmap != null && ((needWidth != slamBitmap.getWidth() || needHeight != slamBitmap.getHeight()) || unconditionalRecreate)) {
            MyLogger.d(TAG, "reCreate the bitmap................");
            slamBitmap.recycle();
            slamBitmap = Bitmap.createBitmap(needWidth, needHeight, Bitmap.Config.ARGB_8888);
            slamCanvas.setBitmap(slamBitmap);
            unconditionalRecreate = false;
        }
        mVirtualWallHelper.updateVirtualWall();
        mForbiddenHelper.updateFbdPath();
        mCleanHelper.updateCleanAreaPath();
    }

    private float caculateSystemScale(int xLength, int yLength, int scale) {
        float systemW = (width * 0.9f) / ((xLength * scale));
        float systemH = (height * 0.9f) / ((yLength * scale));
        float value = Math.min(systemH, systemW);
        if (value > 0.3f || scale - 10 == 0) {
            baseScare = scale;
            return value;
        } else {
            return caculateSystemScale(xLength, yLength, scale - 10);
        }
    }

    /**
     * s
     *
     * @param originalCoordinate
     * @return
     */
    public float matrixCoordinateX(float originalCoordinate) {
        return (originalCoordinate - slamRect.left) * baseScare + extraWH / 2f;
    }

    public float reMatrixCoordinateX(float originalCoordinate) {
        return (originalCoordinate - extraWH / 2f) / baseScare + slamRect.left;
    }

    /**
     * s
     *
     * @param originalCoordinate
     * @return
     */
    public float matrixCoordinateY(float originalCoordinate) {
        return (originalCoordinate - slamRect.top) * baseScare + extraWH / 2f;
    }

    public float reMatrixCoordinateY(float originalCoordinate) {
        return (originalCoordinate - extraWH / 2f) / baseScare + slamRect.top;
    }


    /**
     * roadPath layer matrix
     *
     * @param canvas
     */
    // TODO 手势缩放移动的时候延迟刷新实时地图数据/或者生成刷新队列
    @Override
    protected void onDraw(Canvas canvas) {
        if (slamCanvas != null && slamBitmap != null) {
            matrix.reset();
            matrix.postTranslate(dragX + sCenter.x - slamBitmap.getWidth() / 2f, dragY + sCenter.y - slamBitmap.getHeight() / 2f);
            matrix.postScale(getRealScare(), getRealScare(), sCenter.x, sCenter.y);
            canvas.drawBitmap(slamBitmap, matrix, mPaintManager.getMapPaint());
            canvas.concat(matrix);//应用变换

            /**
             * draw  forbidden area,which contains global area and mop area
             */
            VirtualWallBean fbd;
            for (int i = mForbiddenHelper.getFbdBeans().size() - 1; i >= 0; i--) {
                fbd = mForbiddenHelper.getFbdBeans().get(i);
                if (fbd.getState() == 3) {
                    continue;
                }
                if (fbd.getPath() != null) {
                    canvas.drawPath(fbd.getPath(), mPaintManager.changeColor(mPaintManager.getFillPaint(), fbd.getType() == ForbiddenAreaHelper.TYPE_GLOBAL ? PaintColor.GLOBAL_AREA : PaintColor.MOP_AREA));
                    canvas.drawPath(fbd.getPath(), mPaintManager.changeColor(mPaintManager.getStrokePaint(), fbd.getType() == ForbiddenAreaHelper.TYPE_GLOBAL ? PaintColor.GLOBAL_AREA_BOUNDARY : PaintColor.MOP_AREA_BOUNDARY));
                }
                if ((mOT == OT.MOP_FORBIDDEN_AREA || mOT == OT.GLOBAL_FORBIDDEN_AREA) && mForbiddenHelper.getSelectVwNum() == fbd.getNumber()) {//保存操作中的禁区
                    if (fbd.getBoundaryPath() != null) {
                        canvas.drawPath(fbd.getBoundaryPath(), mPaintManager.changeColor(mPaintManager.getStrokePaint(), PaintColor.RECTANGLE_BOUNDARY));
                    }
                    if (fbd.getDeleteIcon() != null) {
                        canvas.drawBitmap(deleteBitmap, fbd.getDeleteIcon().left, fbd.getDeleteIcon().top, mPaintManager.getIconPaint());
                    }
                    if (fbd.getPullIcon() != null) {
                        canvas.drawBitmap(pullBitmap, fbd.getPullIcon().left, fbd.getPullIcon().top, mPaintManager.getIconPaint());
                    }
                    if (fbd.getRotateIcon() != null) {
                        canvas.drawBitmap(rotateBitmap, fbd.getRotateIcon().left, fbd.getRotateIcon().top, mPaintManager.getIconPaint());
                    }
                }
            }
            /**
             * 预览禁区
             */
            canvas.drawRect(mForbiddenHelper.getCurRectF(), mPaintManager.changeColor(mPaintManager.getFillPaint(), mOT == OT.GLOBAL_FORBIDDEN_AREA ? PaintColor.GLOBAL_AREA : PaintColor.MOP_AREA));

            /**
             *
             *  draw clean area
             *  绘制清扫区域/划区清扫
             */
            if (mOT == OT.MAP || mOT == OT.CLEAN_AREA) {
                VirtualWallBean cleanArea = mCleanHelper.getCurCleanAreaBean();
                if (cleanArea != null && cleanArea.getState() != 3) {
                    if (cleanArea.getPath() != null) {
                        canvas.drawPath(cleanArea.getPath(), mPaintManager.changeColor(mPaintManager.getFillPaint(), PaintColor.CLEAN_AREA));
                        canvas.drawPath(cleanArea.getPath(), mPaintManager.changeColor(mPaintManager.getStrokePaint(), PaintColor.CLEAN_AREA_BOUNDARY));

                    }
                    if (mOT == OT.CLEAN_AREA) {
                        if (cleanArea.getBoundaryPath() != null) {
                            canvas.drawPath(cleanArea.getBoundaryPath(), mPaintManager.changeColor(mPaintManager.getStrokePaint(), PaintColor.RECTANGLE_BOUNDARY));
                        }
                        if (cleanArea.getDeleteIcon() != null) {
                            canvas.drawBitmap(deleteBitmap, cleanArea.getDeleteIcon().left, cleanArea.getDeleteIcon().top, mPaintManager.getIconPaint());
                        }
                        if (cleanArea.getPullIcon() != null) {
                            canvas.drawBitmap(pullBitmap, cleanArea.getPullIcon().left, cleanArea.getPullIcon().top, mPaintManager.getIconPaint());
                        }
                        if (cleanArea.getRotateIcon() != null) {
                            canvas.drawBitmap(rotateBitmap, cleanArea.getRotateIcon().left, cleanArea.getRotateIcon().top, mPaintManager.getIconPaint());
                        }
                    }
                }
                canvas.drawRect(mCleanHelper.getCurRectF(), mPaintManager.changeColor(mPaintManager.getFillPaint(), PaintColor.CLEAN_AREA));
            }

            /**
             * draw virtual wall
             */
            canvas.drawPath(mVirtualWallHelper.getVwPath(), mPaintManager.changeColor(mPaintManager.getLinePaint(), PaintColor.VIRTUAL));
            /**
             * 正在操作虚拟墙的预览
             */
            RectF curVw = mVirtualWallHelper.getCurVw();
            if (curVw.left != 0) {
                canvas.drawLine(curVw.left, curVw.top, curVw.right, curVw.bottom, mPaintManager.changeColor(mPaintManager.getLinePaint(), PaintColor.VIRTUAL));
            }
            for (VirtualWallBean vw : mVirtualWallHelper.getVwBeans()) {
                if (vw.getState() == 3) {
                    continue;
                }
                if (mOT == OT.VIRTUAL_WALL && mVirtualWallHelper.getSelectVwNum() == vw.getNumber()) {
                    if (vw.getBoundaryPath() != null) {
                        canvas.drawPath(vw.getBoundaryPath(), mPaintManager.changeColor(mPaintManager.getStrokePaint(), PaintColor.RECTANGLE_BOUNDARY));
                    }
                    if (vw.getDeleteIcon() != null) {
                        canvas.drawBitmap(deleteBitmap, vw.getDeleteIcon().left, vw.getDeleteIcon().top, mPaintManager.getIconPaint());
                    }
                    if (vw.getPullIcon() != null) {
                        canvas.drawBitmap(pullBitmap, vw.getPullIcon().left, vw.getPullIcon().top, mPaintManager.getIconPaint());
                    }
                }
            }
            /**
             * 绘制分割房间线
             */

            if (mOT == OT.MAP || mOT == OT.SEGMENT_ROOM) {
                if (mSegmentHelper.isHaveLine()) {
                    canvas.drawLines(mSegmentHelper.getmCoordinates(), mPaintManager.changeColor(mPaintManager.getDashPaint(), PaintColor.VIRTUAL));
                    if (mSegmentHelper.isNeedCalculateGate()) {
                        canvas.drawLines(mSegmentHelper.getGateCoordinates(), mPaintManager.changeColor(mPaintManager.getLinePaint(), PaintColor.ROOM_GATE));
                    }
                    canvas.drawCircle(mSegmentHelper.getStartCircle().centerX(), mSegmentHelper.getStartCircle().centerY(),mSegmentHelper.getRadius(), mPaintManager.changeColor(mPaintManager.getFillPaint(), PaintColor.ROOM_GATE));
                    canvas.drawCircle(mSegmentHelper.getEndCircle().centerX(), mSegmentHelper.getEndCircle().centerY(), mSegmentHelper.getRadius(), mPaintManager.changeColor(mPaintManager.getFillPaint(), PaintColor.ROOM_GATE));
                }
            }
            /**
             * draw room tag/绘制房间标记
             * 选房清扫，分割房间清扫；
             */
            if (mOT == OT.MAP || mOT == OT.SELECT_ROOM || mOT == OT.SEGMENT_ROOM) {
                Paint paint = mPaintManager.getFillPaint();
                paint.setTextSize(mRoomHelper.getTextSize());
                for (PartitionBean room : mRoomHelper.getRooms()) {
                    int cx = (int) matrixCoordinateX(room.getX());
                    int cy = (int) matrixCoordinateY(room.getY());
                    canvas.drawCircle(cx, cy, mRoomHelper.getRadius(), mPaintManager.changeColor(mPaintManager.getFillPaint(), PaintColor.ROOM));
                    mPaintManager.changeColor(paint, mRoomHelper.isRoomSelected(room.getPartitionId()) ? PaintColor.ROOM_TEXT_SELECT : PaintColor.ROOM_TEXT);
                    // 文字宽
                    float textWidth = paint.measureText(room.getTag());
                    // 文字baseline在y轴方向的位置
                    float baseLineY = Math.abs(paint.ascent() + paint.descent()) / 2;
                    canvas.drawText(room.getTag(), cx - textWidth / 2, cy + baseLineY, paint);
                }
            }
            /**
             * 绘制充电座
             */
            if (standPointF != null && isChargingPortDisplay) {
                float width = standBitmap.getWidth() / 2f;
                canvas.drawBitmap(standBitmap, matrixCoordinateX(standPointF.x) - width, matrixCoordinateY(standPointF.y) - width, mPaintManager.getIconPaint());
            }
        }
        super.onDraw(canvas);
    }

    public float getEndX() {
        return endX;
    }

    public float getEndY() {
        return endY;
    }

    @Override
    protected void onSizeChanged(int w, int h, int oldw, int oldh) {
        super.onSizeChanged(w, h, oldw, oldh);
        width = w;
        height = h;
        sCenter.set(width / 2f, (height - paddingBottom) / 2f);
    }

    private float getRealScare() {
        return userScale * systemScale;
    }

    private float getOffsetX() {
        float actualDragX = dragX + sCenter.x - (slamBitmap == null ? 0 : slamBitmap.getWidth() / 2f);
        return sCenter.x * (getRealScare() - 1) / getRealScare() - actualDragX;
    }

    private float getOffsetY() {
        float actualDragY = dragY + sCenter.y - (slamBitmap == null ? 0 : slamBitmap.getHeight() / 2f);
        return sCenter.y * (getRealScare() - 1) / getRealScare() - actualDragY;
    }


    // TODO 重绘事件不要太频繁，真正有需求的时候才能调用
    //TODO 优化：删除电子墙的时候支持拖动,添加电子墙的时候支持缩放，NONE时支持缩放和拖动
    @Override
    public boolean onTouchEvent(MotionEvent event) {
        int me = event.getAction() & MotionEvent.ACTION_MASK;
        float x = event.getX() / getRealScare() + getOffsetX();
        float y = event.getY() / getRealScare() + getOffsetY();
        switch (mOT) {
            case NOON:
            case SELECT_ROOM:

            case MAP://操作地图
                switch (me) {
                    case MotionEvent.ACTION_CANCEL:
                    case MotionEvent.ACTION_DOWN:
                        if (isNeedRestore && restoreRunnable != null) {
                            removeCallbacks(restoreRunnable);
                        }
                        downPoint.set(x, y);
                        MAP_MODE = DRAG;
                        break;
                    case MotionEvent.ACTION_MOVE:
                        switch (MAP_MODE) {
                            case ZOOM:
                                if (event.getPointerCount() == 2) {
                                    calculateScale(event);
                                }
                                break;
                            case DRAG:
                                dragX += x - downPoint.x;
                                dragY += y - downPoint.y;
                                break;
                        }
                        invalidateUI();
                        break;
                    case MotionEvent.ACTION_UP:
                        if (x == downPoint.x && y == downPoint.y) {//点击事件
                            MAP_MODE = MODE_NONE;
                            switch (mOT) {
                                case SELECT_ROOM:
                                    mRoomHelper.clickRoomTag(x, y);
                                    break;
                                case PARTITION:
                                    break;

                            }
                        } else {
                            boolean needResetChange = false;
                            switch (MAP_MODE) {
                                case ZOOM:
                                    originalScale = userScale;
                                    MAP_MODE = MODE_NONE;
                                    needResetChange = true;
                                    break;
                                case DRAG:
                                    needResetChange = true;
                                    MAP_MODE = MODE_NONE;
                                    break;
                            }

                            if (needResetChange) {
                                if (isNeedRestore && restoreRunnable == null) {
                                    restoreRunnable = () -> {
                                        userScale = 1;
                                        originalScale = 1;
                                        dragX = 0;
                                        dragY = 0;
                                        invalidateUI();
                                        MyLogger.d(TAG, "-------restore map to the original state----------");
                                    };
                                }
                            }
                        }
                        break;
                    case MotionEvent.ACTION_POINTER_UP:
                        if (MAP_MODE == ZOOM) {
                            userScale = new BigDecimal(userScale).setScale(1, BigDecimal.ROUND_HALF_UP).floatValue();
                        }
                        break;
                    case MotionEvent.ACTION_POINTER_DOWN://多指DOWN
                        if (event.getPointerCount() == 2) {//双指
                            MAP_MODE = ZOOM;
                            beforeDistance = distance(event);
                        }
                        break;
                }
                break;
            case VIRTUAL_WALL://虚拟墙
                mVirtualWallHelper.onTouch(event, x, y);
                break;
            case MOP_FORBIDDEN_AREA://抹地禁区
            case GLOBAL_FORBIDDEN_AREA://全局禁区
                mForbiddenHelper.onTouch(event, (int) x, (int) y);
                break;
            case CLEAN_AREA:
                mCleanHelper.onTouch(event, (int) x, (int) y);
                break;
            case SEGMENT_ROOM:
                mSegmentHelper.onTouch(event, (int) x, (int) y);
                break;
        }
        return true;
    }

    private void calculateScale(MotionEvent event) {
        float afterDistance = distance(event);
        if (Math.abs(afterDistance - beforeDistance) > 10) {
            userScale = (afterDistance / beforeDistance) * originalScale;
            float minScale = 0.6f;
            if (userScale < minScale) {
                userScale = minScale;
            }
            float maxScale = 2.0f / systemScale;
            if (userScale > maxScale) {
                userScale = maxScale;
            }
        }
    }

    private float distance(float x1, float y1, float x2, float y2) {
        float x = x1 - x2;
        float y = y1 - y2;
        return (float) Math.sqrt(x * x + y * y);
    }

    /**
     * 计算两个手指间的距离
     *
     * @param event 触摸事件
     * @return 放回两个手指之间的距离
     */
    private float distance(MotionEvent event) {
        float x = 0;
        float y = 0;
        try {
            x = event.getX(0) - event.getX(1);
            y = event.getY(0) - event.getY(1);
        } catch (IllegalArgumentException e) {
            e.printStackTrace();
        }
        return (float) Math.sqrt(x * x + y * y);//两点间距离公式
    }


    @Override
    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
        final int width = getMySize(widthMeasureSpec);
        final int height = getMySize(heightMeasureSpec);
        setMeasuredDimension(width, height);
    }

    /**
     * 获取测量大小
     */
    private int getMySize(int measureSpec) {
        int result;
        int specMode = MeasureSpec.getMode(measureSpec);
        int specSize = MeasureSpec.getSize(measureSpec);
        int DEFAULT_SIZE = 1500;
        if (specMode == MeasureSpec.EXACTLY) {
            result = specSize;//确切大小,所以将得到的尺寸给view
        } else if (specMode == MeasureSpec.AT_MOST) {
            //默认值为450px,此处要结合父控件给子控件的最多大小(要不然会填充父控件),所以采用最小值
            result = Math.min(DEFAULT_SIZE, specSize);
        } else {
            result = DEFAULT_SIZE;
        }
        return result;
    }


    /**
     * 撤销所有电子墙操作，恢复到与服务器数据一致的状态
     */
    public void undoAllOperation() {
        mVirtualWallHelper.undoAllOperation();
    }

    /**
     * 获取电子墙列表,包含新增，和删除
     *
     * @return
     */
    public String getVirtualWallPointfs() {
        return mVirtualWallHelper.getVwData();
    }


    /**
     * 获取禁区数据，包含全局禁区，抹地禁区
     *
     * @return
     */
    public String getForbiddenData() {
        return mForbiddenHelper.getFbdaData();
    }

    /**
     * 获取清扫区域数据
     *
     * @return
     */
    public String getCleanAreaData() {
        return mCleanHelper.getCleanAreaData();
    }

    /**
     * 获取房间数据
     *
     * @return
     */
    public int getSelectRoom() {
        return mRoomHelper.getSelectRoomId();
    }


    /**
     * 查询到服务其电子墙数据后调用绘制电子墙
     *
     * @param vwData 服务器电子墙数据集合
     */
    public void drawVirtualWall(String vwData) {
        mVirtualWallHelper.setVirtualWall(vwData);
        invalidateUI();
    }

    public VirtualWallHelper getmVirtualWallHelper() {
        return mVirtualWallHelper;
    }

    public ForbiddenAreaHelper getmForbiddenHelper() {
        return mForbiddenHelper;
    }

    public RoomHelper getmRoomHelper() {
        return mRoomHelper;
    }

    /**
     * 查询到房间标记数据后，绘制房间标记
     *
     * @param roomData
     */
    public void drawRoomTag(String roomData) {
        mRoomHelper.drawRoom(roomData);
    }

    public void drawCleanArea(String cleanArea) {
        mCleanHelper.setCleanArea(cleanArea);
    }

    /**
     * 主机坐标系，充电座坐标
     *
     * @param x
     * @param y
     */
    public void drawChargePort(int x, int y, boolean isDisplay) {
        if (standPointF == null) {
            standPointF = new PointF();
        }
        isChargingPortDisplay = isDisplay;
        standPointF.set(x, y);
        invalidateUI();
    }

    /**
     * 从(0,1500)开始向上一行行绘制slam map
     */
    private void drawSlamMap(byte[] slamBytes) {
        int x = 0, y = 0, length, totalCount = 0;
        if (slamBytes != null && slamBytes.length > 0) {
            slamPath.reset();
            obstaclePath.reset();
            for (int i = 0; i < slamBytes.length; i += 3) {
                byte attr = slamBytes[i];
                length = DataUtils.bytesToInt2(new byte[]{slamBytes[i + 1], slamBytes[i + 2]}, 0);
                int distanceTo1500 = 1500 - totalCount;
                switch (attr) {
                    case 0x03://未探索区域
                        if (length > 1500) {
                            duplicateLine(y);//避免线段的结尾和新线段的开始部分是未探索区域，导致slam绘制不完整
                            y += length / 1500;
                            length = length % 1500;
                        }
                        if (length < distanceTo1500) {
                            x += length;
                            totalCount += length;
                        } else {
                            x = length - distanceTo1500;
                            duplicateLine(y);
                            y++;
                            totalCount = x;
                        }
                        break;
                    case 0x01://障碍物
                    case 0x02://已探索区域
                        if (length > 1500) {
                            duplicateLine(y);
                            for (int j = 0; j < length / 1500; j++) {
                                y++;
                                lastLineBeans.add(new SlamLineBean(attr, 0, x));
                            }
                            length = length % 1500;
                        }

                        if (length < distanceTo1500) {
                            x += length;
                            totalCount += length;
                            lastLineBeans.add(new SlamLineBean(attr, x - length, x));
                        } else {
                            lastLineBeans.add(new SlamLineBean(attr, x, 1500));
                            duplicateLine(y);
                            y++;
                            x = length - distanceTo1500;
                            lastLineBeans.add(new SlamLineBean(attr, 0, x));
                            totalCount = x;
                        }
                        break;
                }
            }
        }
    }


    /**
     * 复制startY行的所有线段路径
     *
     * @param startY
     */
    private void duplicateLine(int startY) {
        if (lastLineBeans == null || lastLineBeans.size() == 0) {
            return;
        }
        //切换到下一行绘制
        for (int j = 0; j < baseScare; j += 4) {
            for (SlamLineBean slb : lastLineBeans) {
                Path realPath = slb.getType() == 0x01 ? obstaclePath : slamPath;
                realPath.moveTo(matrixCoordinateX(slb.getStartX()), matrixCoordinateY(1500 - startY) + j);
                realPath.lineTo(matrixCoordinateX(slb.getEndX()), matrixCoordinateY(1500 - startY) + j);
            }
        }
        lastLineBeans.clear();//清空所有线的数据
    }


    /**
     * 绘制x800的黄方格地图
     *
     * @param dataList
     */
    private void drawBoxMapX8(List<Coordinate> dataList) {
        endX = 0;
        endY = 0;
        MyLogger.d(TAG, "drawBoxMapX8-------数据长度：   " + dataList.size());
        if (slamCanvas == null) {
            slamCanvas = new Canvas();
            slamBitmap = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);
            slamCanvas.setBitmap(slamBitmap);
        }
        if (dataList.size() == 0) {
            boxPath.reset();
            obstaclePath.reset();
            roomGatePath.reset();
            roadPath.reset();
            slamCanvas.drawColor(Color.TRANSPARENT, PorterDuff.Mode.CLEAR);
            invalidateUI();
            return;
        }
        pointList.clear();
        pointList.addAll(dataList);
        boxPath.reset();
        roadPath.reset();
        roomGatePath.reset();
        obstaclePath.reset();
        int x, y, type;
        Coordinate coordinate;
        boolean isStartRoad = false;
        if (pointList.size() > 0) {
            for (int i = 0; i < pointList.size(); i++) {
                coordinate = pointList.get(i);
                x = coordinate.getX();
                y = coordinate.getY();
                type = coordinate.getType();
                switch (type) {
                    case 0:
                        //未清扫区域
                        break;
                    case 1://已清扫
                        boxPath.addRect(matrixCoordinateX(x), matrixCoordinateY(y), matrixCoordinateX(x) + baseScare, matrixCoordinateY(y) + baseScare, Path.Direction.CCW);
                        break;
                    case 2://障碍物
                        obstaclePath.addRect(matrixCoordinateX(x), matrixCoordinateY(y), matrixCoordinateX(x) + baseScare, matrixCoordinateY(y) + baseScare, Path.Direction.CCW);
                        break;
                    case 3://房间门
                        roomGatePath.addRect(matrixCoordinateX(x), matrixCoordinateY(y), matrixCoordinateX(x) + baseScare, matrixCoordinateY(y) + baseScare, Path.Direction.CCW);
                        break;
                    case -1://单包路径起点
                        roadPath.moveTo(matrixCoordinateX(x), matrixCoordinateY(y));
                        break;
                    case 4://路径
                        if (!isStartRoad) {
                            isStartRoad = true;
                            roadPath.moveTo(matrixCoordinateX(x), matrixCoordinateY(y));
                        } else {
                            roadPath.lineTo(matrixCoordinateX(x), matrixCoordinateY(y));
                        }
                        endX = matrixCoordinateX(x);
                        endY = matrixCoordinateY(y);
                        break;
                }
            }
        }
    }


    public void invalidateUI() {
        MyLogger.d(TAG, "invalidateUI");
        if (Looper.getMainLooper() == Looper.myLooper()) {
            invalidate();
        } else {
            postInvalidate();
        }
    }

    @Override
    protected void onAttachedToWindow() {
        super.onAttachedToWindow();
    }

    @Override
    protected void onDetachedFromWindow() {
        super.onDetachedFromWindow();
//        if (slamBitmap != null) {
//            slamBitmap.recycle();
//            slamBitmap = null;
//        }
//        if (slamCanvas != null) {
//            slamCanvas = null;
//        }
        if (deleteBitmap != null) {
            deleteBitmap.recycle();
        }
        if (rotateBitmap != null) {
            rotateBitmap.recycle();
        }
        if (pullBitmap != null) {
            pullBitmap.recycle();
        }
    }

    private class PaintManager {
        private Paint slamPaint, linePaint, roadPaint, mapPaint, fillPaint, strokePaint, iconPaint, textPaint, dashPaint;

        public PaintManager() {
            initPaint();
        }

        public void initPaint() {
            slamPaint = new Paint(Paint.ANTI_ALIAS_FLAG | Paint.DITHER_FLAG);
            buildPaint(slamPaint, getResources().getColor(R.color.slam_color), Paint.Style.FILL_AND_STROKE, 1);

            fillPaint = new Paint(Paint.ANTI_ALIAS_FLAG | Paint.DITHER_FLAG);
            buildPaint(fillPaint, getResources().getColor(R.color.slam_color), Paint.Style.FILL_AND_STROKE, 1, Paint.Join.ROUND);

            mapPaint = new Paint(Paint.ANTI_ALIAS_FLAG | Paint.DITHER_FLAG);
            buildPaint(mapPaint, getResources().getColor(R.color.slam_color), Paint.Style.FILL_AND_STROKE, 1, Paint.Join.ROUND);

            linePaint = new Paint(Paint.ANTI_ALIAS_FLAG | Paint.DITHER_FLAG);
            buildPaint(linePaint, getResources().getColor(R.color.color_theme), Paint.Style.FILL_AND_STROKE, 10, Paint.Join.ROUND);

            dashPaint = new Paint(Paint.ANTI_ALIAS_FLAG | Paint.DITHER_FLAG);
            buildPaint(dashPaint, getResources().getColor(R.color.color_theme), Paint.Style.FILL_AND_STROKE, 10, Paint.Join.ROUND);
            PathEffect pathEffect = new DashPathEffect(new float[]{20, 20}, 0);
            dashPaint.setPathEffect(pathEffect);

            roadPaint = new Paint(Paint.ANTI_ALIAS_FLAG | Paint.DITHER_FLAG);
            buildPaint(roadPaint, getResources().getColor(R.color.white), Paint.Style.STROKE, 4, Paint.Join.ROUND);

            textPaint = new Paint();
            buildPaint(textPaint, getResources().getColor(R.color.color_theme), Paint.Style.FILL_AND_STROKE, 1, Paint.Join.ROUND);


            strokePaint = new Paint(Paint.ANTI_ALIAS_FLAG | Paint.DITHER_FLAG);
            buildPaint(strokePaint, getResources().getColor(R.color.color_1adb2d), Paint.Style.STROKE, 10, Paint.Join.ROUND);
            iconPaint = new Paint(Paint.ANTI_ALIAS_FLAG | Paint.DITHER_FLAG);
            buildPaint(iconPaint, getResources().getColor(R.color.color_theme), Paint.Style.FILL_AND_STROKE, 10);
        }

        /**
         * 构建普通画笔
         *
         * @param paint
         * @param color
         * @param style
         * @param width
         */
        private void buildPaint(Paint paint, int color, Paint.Style style, float width) {
            paint.setStyle(style);
            paint.setFilterBitmap(true);
            paint.setColor(color);
            paint.setStrokeWidth(width);
        }

        /**
         * 构建绘制路径类型的画笔
         *
         * @param paint
         * @param color
         * @param style
         * @param width
         * @param join
         */
        private void buildPaint(Paint paint, int color, Paint.Style style, float width, Paint.Join join) {
            paint.setFilterBitmap(true);
            paint.setStyle(style);
            paint.setStrokeJoin(join);
            paint.setColor(color);
            paint.setStrokeWidth(width);
        }

        public Paint changeColor(Paint paint, PaintColor color) {
            paint.setColor(color.color);
            return paint;
        }

        /**
         * 转换画笔为描边画笔
         *
         * @param paint
         */
        public Paint toStokeStyle(Paint paint) {
            paint.setStyle(Paint.Style.STROKE);
            return paint;
        }

        /**
         * 转换画笔为填充描边画笔
         *
         * @param paint
         */
        public Paint toFillStyle(Paint paint) {
            paint.setStyle(Paint.Style.FILL_AND_STROKE);
            return paint;
        }

        public Paint getDashPaint() {
            return dashPaint;
        }

        public Paint getTextPaint() {
            return textPaint;
        }

        public Paint getSlamPaint() {
            return slamPaint;
        }

        public void setSlamPaint(Paint slamPaint) {
            this.slamPaint = slamPaint;
        }

        public Paint getLinePaint() {
            return linePaint;
        }

        public void setLinePaint(Paint linePaint) {
            this.linePaint = linePaint;
        }

        public Paint getFillPaint() {
            return fillPaint;
        }

        public void setFillPaint(Paint fillPaint) {
            this.fillPaint = fillPaint;
        }

        public Paint getStrokePaint() {
            return strokePaint;
        }

        public void setStrokePaint(Paint strokePaint) {
            this.strokePaint = strokePaint;
        }

        public Paint getIconPaint() {
            return iconPaint;
        }

        public void setIconPaint(Paint iconPaint) {
            this.iconPaint = iconPaint;
        }

        public Paint getRoadPaint() {
            return roadPaint;
        }

        public void setRoadPaint(Paint roadPaint) {
            this.roadPaint = roadPaint;
        }

        public Paint getMapPaint() {
            return mapPaint;
        }
    }

    enum PaintColor {
        SLAM(1, UiUtil.getColorByARGB("#545358")),
        ROAD(2, UiUtil.getColorByARGB("#FFFFFF")),
        OBSTACLE(3, UiUtil.getColorByARGB("#FF75767A")),
        RECTANGLE_BOUNDARY(4, UiUtil.getColorByARGB("#FFFFFF")),
        VIRTUAL(5, UiUtil.getColorByARGB("#F31E1B")),
        GLOBAL_AREA(6, UiUtil.getColorByARGB("#4DF91F1F")),
        GLOBAL_AREA_BOUNDARY(7, UiUtil.getColorByARGB("#F91F1F")),
        MOP_AREA(8, UiUtil.getColorByARGB("#4DEF7C00")),
        MOP_AREA_BOUNDARY(9, UiUtil.getColorByARGB("#EF7C00")),
        CLEAN_AREA(10, UiUtil.getColorByARGB("#4D1B92E2")),
        CLEAN_AREA_BOUNDARY(11, UiUtil.getColorByARGB("#1B92E2")),
        END_CIRCLE(11, UiUtil.getColorByARGB("#FFF700")),
        ROOM(12, UiUtil.getColorByARGB("#1A000000")),
        ROOM_TEXT_SELECT(13, UiUtil.getColorByARGB("#EF7C00")),
        ROOM_TEXT(14, UiUtil.getColorByARGB("#FFFFFF")),
        ROOM_GATE(15, UiUtil.getColorByARGB("#EF7C00"));
        final int type;
        final int color;

        PaintColor(int type, int color) {
            this.type = type;
            this.color = color;
        }
    }

    public float getSystemScale() {
        return systemScale;
    }

    public float getBaseScare() {
        return baseScare;
    }

    public ArrayList<Coordinate> getPointList() {
        return pointList;
    }
}
